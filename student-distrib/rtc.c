#include "rtc.h"
#include "i8259.h"
#include "lib.h"


uint32_t frequency;
uint32_t int_times;             //num of interrupts in a second
uint32_t seconds;               //seconds gone
uint32_t interrupts_occured;     //used by read rtc

/* void RTC_init
 * initializa the RTC 
 * Inputs: uint8 rate
 * Return Value: void
 * side effect: enable IR8 in PIC*/
void RTC_init(){  
    char prev;
    frequency=2;
    int_times=0;
    seconds=0;          
    outb(RTC_PORT,RTC_REG_B);		    // select register B, and disable NMI
    prev=inb(RTC_PORT_CMOS);	// initial value of register B
    outb(RTC_PORT,RTC_REG_B);		    // set the index again because a read will reset the index to register D
    outb(prev | 0x40, RTC_PORT_CMOS);	// turns on bit 6 of register B (UIE)

                
    outb(RTC_REG_A,RTC_PORT);                   // select register A, disable NMI
    prev=inb(RTC_PORT_CMOS);	            // initial value of register A
    outb(RTC_REG_A,RTC_PORT);		            // set the index again because a read will reset the index to register D
    outb((prev & 0xF0) | 6,RTC_PORT_CMOS);   // write the rate to low 4 bits of Register A
                                            // we use 6 because the actual rate is 6, and actual frequency is 1024
    enable_irq(RTC_IRQ_NUM);
}
/* rtc_open
 * open the pic
 * Inputs: a pointer to a file(file name)
 * Return Value: 0 on sucess
 * side effect: set the frequency to 2*/
int32_t rtc_open(const uint8_t* filename){
    frequency=2;
    return 0;
}
/* rtc_read
 * read from the rtc
 * Inputs: a int32 fd, a pointer to a buffer, number of bytes we want
 * Return Value: 0 on sucess
 * side effect: none*/
int32_t rtc_read(int32_t fd,void* buf,int32_t nbytes){
    interrupts_occured=0;
    while(interrupts_occured==0);   // wait until we get the interrupt
    return 0;
}
/* rtc_write
 * write frequency to rtc
 * Inputs: a int32 fd, a pointer to a buffer, number of bytes we want 
 * Return Value: 0 on sucess,-1 on failure
 * side effect: none*/
int32_t rtc_write(int32_t fd, const void* buf,int32_t nbytes){
   uint32_t req_fren = *(uint32_t*) buf;
   if(((req_fren)&(req_fren-1))!=0){        //only when it is a power of two, the result will be 0
    return -1;
   }
   if(req_fren>1024){
    return -1;                          //biggest frequency we want 
   }
   frequency = req_fren;
   return 0;
}
/* void rtc_close
 * close the rtc
 * Inputs: int32 fd
 * Return Value: 0 on sucess
 * side effect: none*/
int32_t rtc_close(int32_t fd){
    return 0;
}
/* void handler_rtc
 * handle the interrupts generated by RTC
 * Inputs: void
 * Return Value: void
 * side effect: enable IR8 in PIC*/
void handler_rtc(){
    int_times++;
    if(int_times==1024){        //1024 is actual frequencies
        int_times=0;
        seconds++;
        interrupts_occured=1;   //1024 interrupts is definitely the multiply of the frequencies we want 
    }
    else{
        if(int_times%(1024/frequency)==0)   // 1024/frequency interrupts means we get one time interrupt in freqnecy we want
        interrupts_occured=1;  
    }
    cli();
    outb(RTC_REG_C, RTC_PORT);	// select register C
    inb(RTC_PORT_CMOS);		// just throw away contents
    send_eoi(RTC_IRQ_NUM);
    sti();
}
